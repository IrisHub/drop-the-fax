{"ast":null,"code":"// Copyright 2014, 2015, 2016, 2017 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\n// Note: source-map-resolve.js is generated from source-map-resolve-node.js and\n// source-map-resolve-template.js. Only edit the two latter files, _not_\n// source-map-resolve.js!\nvoid function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"source-map-url\", \"resolve-url\"], factory);\n  } else if (typeof exports === \"object\") {\n    var sourceMappingURL = require(\"source-map-url\");\n\n    var resolveUrl = require(\"resolve-url\");\n\n    module.exports = factory(sourceMappingURL, resolveUrl);\n  } else {\n    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl);\n  }\n}(this, function (sourceMappingURL, resolveUrl) {\n  function callbackAsync(callback, error, result) {\n    setImmediate(function () {\n      callback(error, result);\n    });\n  }\n\n  function parseMapToJSON(string, data) {\n    try {\n      return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n\n  function readSync(read, url, data) {\n    var readUrl = url;\n\n    try {\n      return String(read(readUrl));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n\n  function resolveSourceMap(code, codeUrl, read, callback) {\n    var mapData;\n\n    try {\n      mapData = resolveSourceMapHelper(code, codeUrl);\n    } catch (error) {\n      return callbackAsync(callback, error);\n    }\n\n    if (!mapData || mapData.map) {\n      return callbackAsync(callback, null, mapData);\n    }\n\n    var readUrl = mapData.url;\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = mapData;\n        return callback(error);\n      }\n\n      mapData.map = String(result);\n\n      try {\n        mapData.map = parseMapToJSON(mapData.map, mapData);\n      } catch (error) {\n        return callback(error);\n      }\n\n      callback(null, mapData);\n    });\n  }\n\n  function resolveSourceMapSync(code, codeUrl, read) {\n    var mapData = resolveSourceMapHelper(code, codeUrl);\n\n    if (!mapData || mapData.map) {\n      return mapData;\n    }\n\n    mapData.map = readSync(read, mapData.url, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n    return mapData;\n  }\n\n  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n  var jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n\n  function resolveSourceMapHelper(code, codeUrl) {\n    var url = sourceMappingURL.getFrom(code);\n\n    if (!url) {\n      return null;\n    }\n\n    var dataUri = url.match(dataUriRegex);\n\n    if (dataUri) {\n      var mimeType = dataUri[1];\n      var lastParameter = dataUri[2] || \"\";\n      var encoded = dataUri[3] || \"\";\n      var data = {\n        sourceMappingURL: url,\n        url: null,\n        sourcesRelativeTo: codeUrl,\n        map: encoded\n      };\n\n      if (!jsonMimeTypeRegex.test(mimeType)) {\n        var error = new Error(\"Unuseful data uri mime type: \" + (mimeType || \"text/plain\"));\n        error.sourceMapData = data;\n        throw error;\n      }\n\n      data.map = parseMapToJSON(lastParameter === \";base64\" ? atob(encoded) : decodeURIComponent(encoded), data);\n      return data;\n    }\n\n    var mapUrl = resolveUrl(codeUrl, url);\n    return {\n      sourceMappingURL: url,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n  }\n\n  function resolveSources(map, mapUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n\n    var pending = map.sources ? map.sources.length : 0;\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n\n    if (pending === 0) {\n      callbackAsync(callback, null, result);\n      return;\n    }\n\n    var done = function () {\n      pending--;\n\n      if (pending === 0) {\n        callback(null, result);\n      }\n    };\n\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n        callbackAsync(done, null);\n      } else {\n        var readUrl = fullUrl;\n        read(readUrl, function (error, source) {\n          result.sourcesContent[index] = error ? error : String(source);\n          done();\n        });\n      }\n    });\n  }\n\n  function resolveSourcesSync(map, mapUrl, read, options) {\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n\n    if (!map.sources || map.sources.length === 0) {\n      return result;\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n\n      if (read !== null) {\n        if (typeof sourceContent === \"string\") {\n          result.sourcesContent[index] = sourceContent;\n        } else {\n          var readUrl = fullUrl;\n\n          try {\n            result.sourcesContent[index] = String(read(readUrl));\n          } catch (error) {\n            result.sourcesContent[index] = error;\n          }\n        }\n      }\n    });\n    return result;\n  }\n\n  var endingSlash = /\\/?$/;\n\n  function resolveSourcesHelper(map, mapUrl, options, fn) {\n    options = options || {};\n    var fullUrl;\n    var sourceContent;\n    var sourceRoot;\n\n    for (var index = 0, len = map.sources.length; index < len; index++) {\n      sourceRoot = null;\n\n      if (typeof options.sourceRoot === \"string\") {\n        sourceRoot = options.sourceRoot;\n      } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n        sourceRoot = map.sourceRoot;\n      } // If the sourceRoot is the empty string, it is equivalent to not setting\n      // the property at all.\n\n\n      if (sourceRoot === null || sourceRoot === '') {\n        fullUrl = resolveUrl(mapUrl, map.sources[index]);\n      } else {\n        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n        // does not make sense.\n        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n      }\n\n      sourceContent = (map.sourcesContent || [])[index];\n      fn(fullUrl, sourceContent, index);\n    }\n  }\n\n  function resolve(code, codeUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n\n    if (code === null) {\n      var mapUrl = codeUrl;\n      var data = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      var readUrl = mapUrl;\n      read(readUrl, function (error, result) {\n        if (error) {\n          error.sourceMapData = data;\n          return callback(error);\n        }\n\n        data.map = String(result);\n\n        try {\n          data.map = parseMapToJSON(data.map, data);\n        } catch (error) {\n          return callback(error);\n        }\n\n        _resolveSources(data);\n      });\n    } else {\n      resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!mapData) {\n          return callback(null, null);\n        }\n\n        _resolveSources(mapData);\n      });\n    }\n\n    function _resolveSources(mapData) {\n      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n        if (error) {\n          return callback(error);\n        }\n\n        mapData.sourcesResolved = result.sourcesResolved;\n        mapData.sourcesContent = result.sourcesContent;\n        callback(null, mapData);\n      });\n    }\n  }\n\n  function resolveSync(code, codeUrl, read, options) {\n    var mapData;\n\n    if (code === null) {\n      var mapUrl = codeUrl;\n      mapData = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      mapData.map = readSync(read, mapUrl, mapData);\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } else {\n      mapData = resolveSourceMapSync(code, codeUrl, read);\n\n      if (!mapData) {\n        return null;\n      }\n    }\n\n    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n    mapData.sourcesResolved = result.sourcesResolved;\n    mapData.sourcesContent = result.sourcesContent;\n    return mapData;\n  }\n\n  return {\n    resolveSourceMap: resolveSourceMap,\n    resolveSourceMapSync: resolveSourceMapSync,\n    resolveSources: resolveSources,\n    resolveSourcesSync: resolveSourcesSync,\n    resolve: resolve,\n    resolveSync: resolveSync,\n    parseMapToJSON: parseMapToJSON\n  };\n});","map":{"version":3,"sources":["/Users/shalinshah/Downloads/iris-web/node_modules/source-map-resolve/source-map-resolve.js"],"names":["root","factory","define","amd","exports","sourceMappingURL","require","resolveUrl","module","sourceMapResolve","callbackAsync","callback","error","result","setImmediate","parseMapToJSON","string","data","JSON","parse","replace","sourceMapData","readSync","read","url","readUrl","String","resolveSourceMap","code","codeUrl","mapData","resolveSourceMapHelper","map","resolveSourceMapSync","dataUriRegex","jsonMimeTypeRegex","getFrom","dataUri","match","mimeType","lastParameter","encoded","sourcesRelativeTo","test","Error","atob","decodeURIComponent","mapUrl","resolveSources","options","pending","sources","length","sourcesResolved","sourcesContent","done","resolveSourcesHelper","fullUrl","sourceContent","index","source","resolveSourcesSync","endingSlash","fn","sourceRoot","len","resolve","_resolveSources","resolveSync"],"mappings":"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","sourcesContent":["// Copyright 2014, 2015, 2016, 2017 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\n\n// Note: source-map-resolve.js is generated from source-map-resolve-node.js and\n// source-map-resolve-template.js. Only edit the two latter files, _not_\n// source-map-resolve.js!\n\nvoid (function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"source-map-url\", \"resolve-url\"], factory)\n  } else if (typeof exports === \"object\") {\n    var sourceMappingURL = require(\"source-map-url\")\n    var resolveUrl = require(\"resolve-url\")\n    module.exports = factory(sourceMappingURL, resolveUrl)\n  } else {\n    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl)\n  }\n}(this, function(sourceMappingURL, resolveUrl) {\n\n  function callbackAsync(callback, error, result) {\n    setImmediate(function() { callback(error, result) })\n  }\n\n  function parseMapToJSON(string, data) {\n    try {\n      return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n  }\n\n  function readSync(read, url, data) {\n    var readUrl = url\n    try {\n      return String(read(readUrl))\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n  }\n\n\n\n  function resolveSourceMap(code, codeUrl, read, callback) {\n    var mapData\n    try {\n      mapData = resolveSourceMapHelper(code, codeUrl)\n    } catch (error) {\n      return callbackAsync(callback, error)\n    }\n    if (!mapData || mapData.map) {\n      return callbackAsync(callback, null, mapData)\n    }\n    var readUrl = mapData.url\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = mapData\n        return callback(error)\n      }\n      mapData.map = String(result)\n      try {\n        mapData.map = parseMapToJSON(mapData.map, mapData)\n      } catch (error) {\n        return callback(error)\n      }\n      callback(null, mapData)\n    })\n  }\n\n  function resolveSourceMapSync(code, codeUrl, read) {\n    var mapData = resolveSourceMapHelper(code, codeUrl)\n    if (!mapData || mapData.map) {\n      return mapData\n    }\n    mapData.map = readSync(read, mapData.url, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n    return mapData\n  }\n\n  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n  var jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n  function resolveSourceMapHelper(code, codeUrl) {\n    var url = sourceMappingURL.getFrom(code)\n    if (!url) {\n      return null\n    }\n\n    var dataUri = url.match(dataUriRegex)\n    if (dataUri) {\n      var mimeType = dataUri[1]\n      var lastParameter = dataUri[2] || \"\"\n      var encoded = dataUri[3] || \"\"\n      var data = {\n        sourceMappingURL: url,\n        url: null,\n        sourcesRelativeTo: codeUrl,\n        map: encoded\n      }\n      if (!jsonMimeTypeRegex.test(mimeType)) {\n        var error = new Error(\"Unuseful data uri mime type: \" + (mimeType || \"text/plain\"))\n        error.sourceMapData = data\n        throw error\n      }\n      data.map = parseMapToJSON(\n        lastParameter === \";base64\" ? atob(encoded) : decodeURIComponent(encoded),\n        data\n      )\n      return data\n    }\n\n    var mapUrl = resolveUrl(codeUrl, url)\n    return {\n      sourceMappingURL: url,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n  }\n\n\n\n  function resolveSources(map, mapUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options\n      options = {}\n    }\n    var pending = map.sources ? map.sources.length : 0\n    var result = {\n      sourcesResolved: [],\n      sourcesContent:  []\n    }\n\n    if (pending === 0) {\n      callbackAsync(callback, null, result)\n      return\n    }\n\n    var done = function() {\n      pending--\n      if (pending === 0) {\n        callback(null, result)\n      }\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent\n        callbackAsync(done, null)\n      } else {\n        var readUrl = fullUrl\n        read(readUrl, function(error, source) {\n          result.sourcesContent[index] = error ? error : String(source)\n          done()\n        })\n      }\n    })\n  }\n\n  function resolveSourcesSync(map, mapUrl, read, options) {\n    var result = {\n      sourcesResolved: [],\n      sourcesContent:  []\n    }\n\n    if (!map.sources || map.sources.length === 0) {\n      return result\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl\n      if (read !== null) {\n        if (typeof sourceContent === \"string\") {\n          result.sourcesContent[index] = sourceContent\n        } else {\n          var readUrl = fullUrl\n          try {\n            result.sourcesContent[index] = String(read(readUrl))\n          } catch (error) {\n            result.sourcesContent[index] = error\n          }\n        }\n      }\n    })\n\n    return result\n  }\n\n  var endingSlash = /\\/?$/\n\n  function resolveSourcesHelper(map, mapUrl, options, fn) {\n    options = options || {}\n    var fullUrl\n    var sourceContent\n    var sourceRoot\n    for (var index = 0, len = map.sources.length; index < len; index++) {\n      sourceRoot = null\n      if (typeof options.sourceRoot === \"string\") {\n        sourceRoot = options.sourceRoot\n      } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n        sourceRoot = map.sourceRoot\n      }\n      // If the sourceRoot is the empty string, it is equivalent to not setting\n      // the property at all.\n      if (sourceRoot === null || sourceRoot === '') {\n        fullUrl = resolveUrl(mapUrl, map.sources[index])\n      } else {\n        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n        // does not make sense.\n        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\n      }\n      sourceContent = (map.sourcesContent || [])[index]\n      fn(fullUrl, sourceContent, index)\n    }\n  }\n\n\n\n  function resolve(code, codeUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options\n      options = {}\n    }\n    if (code === null) {\n      var mapUrl = codeUrl\n      var data = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      }\n      var readUrl = mapUrl\n      read(readUrl, function(error, result) {\n        if (error) {\n          error.sourceMapData = data\n          return callback(error)\n        }\n        data.map = String(result)\n        try {\n          data.map = parseMapToJSON(data.map, data)\n        } catch (error) {\n          return callback(error)\n        }\n        _resolveSources(data)\n      })\n    } else {\n      resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n        if (error) {\n          return callback(error)\n        }\n        if (!mapData) {\n          return callback(null, null)\n        }\n        _resolveSources(mapData)\n      })\n    }\n\n    function _resolveSources(mapData) {\n      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n        if (error) {\n          return callback(error)\n        }\n        mapData.sourcesResolved = result.sourcesResolved\n        mapData.sourcesContent  = result.sourcesContent\n        callback(null, mapData)\n      })\n    }\n  }\n\n  function resolveSync(code, codeUrl, read, options) {\n    var mapData\n    if (code === null) {\n      var mapUrl = codeUrl\n      mapData = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      }\n      mapData.map = readSync(read, mapUrl, mapData)\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } else {\n      mapData = resolveSourceMapSync(code, codeUrl, read)\n      if (!mapData) {\n        return null\n      }\n    }\n    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n    mapData.sourcesResolved = result.sourcesResolved\n    mapData.sourcesContent  = result.sourcesContent\n    return mapData\n  }\n\n\n\n  return {\n    resolveSourceMap:     resolveSourceMap,\n    resolveSourceMapSync: resolveSourceMapSync,\n    resolveSources:       resolveSources,\n    resolveSourcesSync:   resolveSourcesSync,\n    resolve:              resolve,\n    resolveSync:          resolveSync,\n    parseMapToJSON:       parseMapToJSON\n  }\n\n}));\n"]},"metadata":{},"sourceType":"script"}